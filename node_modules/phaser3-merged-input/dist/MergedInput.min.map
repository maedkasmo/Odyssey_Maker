{"version":3,"sources":["webpack://MergedInput/webpack/universalModuleDefinition","webpack://MergedInput/webpack/bootstrap","webpack://MergedInput/./main.js"],"names":["root","factory","exports","module","define","amd","window","installedModules","__webpack_require__","m","MergedInput","Phaser","Plugins","ScenePlugin","this","gamepads","systems","input","gamepad","filter","el","_iteratorNormalCompletion","_didIteratorError","_iteratorError","undefined","_step","_iterator","entries","Symbol","iterator","next","done","_step$value","_slicedToArray","value","index","err","return","eventEmitter","events","on","update","once","thisGamepad","refreshGamepads","setupGamepad","refreshPads","total","_iteratorNormalCompletion2","_didIteratorError2","_iteratorError2","_step2","_iterator2","emit","keyboard","event","keyCode","Object","keys","Input","Keyboard","KeyCodes","find","key","playerIndex","getPlayerIndexFromKey","getPlayer","interaction","device","mouse","disableContextMenu","pointer","pointerMove","pointerDown","pointerUp","_iteratorNormalCompletion3","_didIteratorError3","_iteratorError3","_step3","_iterator3","players","thisPlayer","buffer","pressed","BEARING","BEARING_DEGREES","ANGLE","direction","mapDirectionsToBearing","BEARING_LAST","DEGREES","parseFloat","mapBearingToDegrees","DEGREES_LAST","direction_secondary","checkKeyboardInput","checkGamepadInput","checkPointerInput","gamepadButtonDown","gamepadButtonUp","id","player","action","addPlayer","_typeof","Number","isInteger","push","setupControls","length","_iteratorNormalCompletion4","_didIteratorError4","_iteratorError4","_step4","_iterator4","thisKey","_iteratorNormalCompletion5","_didIteratorError5","_iteratorError5","_step5","_iterator5","controls","UP","DOWN","LEFT","RIGHT","TIMESTAMP","buttons","M1","M2","M3","M4","M5","position","i","last","arguments","append","includes","addKey","_iteratorNormalCompletion6","_didIteratorError6","_iteratorError6","_step6","_iterator6","_step6$value","_iteratorNormalCompletion7","_didIteratorError7","_iteratorError7","_step7","_iterator7","thisValue","isDown","JustDown","state","JustUp","scene","sys","time","now","replace","_iteratorNormalCompletion8","_didIteratorError8","_iteratorError8","_step8","_iterator8","_step8$value","_iteratorNormalCompletion9","_didIteratorError9","_iteratorError9","_step9","_iterator9","button","pad","_iteratorNormalCompletion10","_didIteratorError10","_iteratorError10","_step10","_iterator10","leftStick","y","Math","abs","up","down","x","left","right","rightStick","b","threshold","distance","getBearingFromAngle","angle","angleToPointer","Angle","Between","worldX","worldY","pointerDirection","pointerAngle","leftButtonDown","rightButtonDown","middleButtonDown","backButtonDown","forwardButtonDown","moveTime","leftButtonReleased","rightButtonReleased","middleButtonReleased","backButtonReleased","forwardButtonReleased","numDirections","snap_interval","PI2","angleSnap","Snap","To","angleSnapDeg","RadToDeg","bearings","bearing","thisDirection","toUpperCase","directions","_this2","shutdown","debug","axes","a","axis","getValue","ID","Index","Buttons","Axes","_iteratorNormalCompletion11","_didIteratorError11","_iteratorError11","_step11","_iterator11","pluginManager","_classCallCheck","_this","_possibleConstructorReturn","__proto__","getPrototypeOf","call","-180","-168.75","-157.5","-146.25","-135","-123.75","-112.5","-101.25","-90","-78.75","-67.5","-56.25","-45","-33.75","-22.5","-11.25","0","11.25","22.5","33.75","45","56.25","67.5","78.75","90","101.25","112.5","123.75","135","146.25","157.5","168.75","180","c","d","name","getter","o","defineProperty","enumerable","get","r","toStringTag","t","mode","__esModule","ns","create","bind","n","object","property","prototype","hasOwnProperty","p","s","moduleId","l","modules"],"mappings":"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","file":"MergedInput.min.js","sourcesContent":["(function webpackUniversalModuleDefinition(root, factory) {\n\tif(typeof exports === 'object' && typeof module === 'object')\n\t\tmodule.exports = factory();\n\telse if(typeof define === 'function' && define.amd)\n\t\tdefine(\"MergedInput\", [], factory);\n\telse if(typeof exports === 'object')\n\t\texports[\"MergedInput\"] = factory();\n\telse\n\t\troot[\"MergedInput\"] = factory();\n})(window, function() {\nreturn "," \t// The module cache\n \tvar installedModules = {};\n\n \t// The require function\n \tfunction __webpack_require__(moduleId) {\n\n \t\t// Check if module is in cache\n \t\tif(installedModules[moduleId]) {\n \t\t\treturn installedModules[moduleId].exports;\n \t\t}\n \t\t// Create a new module (and put it into the cache)\n \t\tvar module = installedModules[moduleId] = {\n \t\t\ti: moduleId,\n \t\t\tl: false,\n \t\t\texports: {}\n \t\t};\n\n \t\t// Execute the module function\n \t\tmodules[moduleId].call(module.exports, module, module.exports, __webpack_require__);\n\n \t\t// Flag the module as loaded\n \t\tmodule.l = true;\n\n \t\t// Return the exports of the module\n \t\treturn module.exports;\n \t}\n\n\n \t// expose the modules object (__webpack_modules__)\n \t__webpack_require__.m = modules;\n\n \t// expose the module cache\n \t__webpack_require__.c = installedModules;\n\n \t// define getter function for harmony exports\n \t__webpack_require__.d = function(exports, name, getter) {\n \t\tif(!__webpack_require__.o(exports, name)) {\n \t\t\tObject.defineProperty(exports, name, { enumerable: true, get: getter });\n \t\t}\n \t};\n\n \t// define __esModule on exports\n \t__webpack_require__.r = function(exports) {\n \t\tif(typeof Symbol !== 'undefined' && Symbol.toStringTag) {\n \t\t\tObject.defineProperty(exports, Symbol.toStringTag, { value: 'Module' });\n \t\t}\n \t\tObject.defineProperty(exports, '__esModule', { value: true });\n \t};\n\n \t// create a fake namespace object\n \t// mode & 1: value is a module id, require it\n \t// mode & 2: merge all properties of value into the ns\n \t// mode & 4: return value when already ns object\n \t// mode & 8|1: behave like require\n \t__webpack_require__.t = function(value, mode) {\n \t\tif(mode & 1) value = __webpack_require__(value);\n \t\tif(mode & 8) return value;\n \t\tif((mode & 4) && typeof value === 'object' && value && value.__esModule) return value;\n \t\tvar ns = Object.create(null);\n \t\t__webpack_require__.r(ns);\n \t\tObject.defineProperty(ns, 'default', { enumerable: true, value: value });\n \t\tif(mode & 2 && typeof value != 'string') for(var key in value) __webpack_require__.d(ns, key, function(key) { return value[key]; }.bind(null, key));\n \t\treturn ns;\n \t};\n\n \t// getDefaultExport function for compatibility with non-harmony modules\n \t__webpack_require__.n = function(module) {\n \t\tvar getter = module && module.__esModule ?\n \t\t\tfunction getDefault() { return module['default']; } :\n \t\t\tfunction getModuleExports() { return module; };\n \t\t__webpack_require__.d(getter, 'a', getter);\n \t\treturn getter;\n \t};\n\n \t// Object.prototype.hasOwnProperty.call\n \t__webpack_require__.o = function(object, property) { return Object.prototype.hasOwnProperty.call(object, property); };\n\n \t// __webpack_public_path__\n \t__webpack_require__.p = \"\";\n\n\n \t// Load entry module and return exports\n \treturn __webpack_require__(__webpack_require__.s = 0);\n","export default class MergedInput extends Phaser.Plugins.ScenePlugin {\n\n    /**\n     * The Merged Input plugin is designed to run in the background and handle input.\n     * Upon detecting a keypress or gamepad interaction, the plugin will update a player object and emit global events.\n     *\n     * @extends Phaser.Scene\n     * @param {*} scene\n     * @param {*} pluginManager\n     */\n    constructor(scene, pluginManager) {\n        super(scene, pluginManager);\n        this.scene = scene;\n\n        // Players\n        this.players = [];\n        // Gamepads\n        this.gamepads = [];\n        // Keys object to store Phaser key objects. We'll check these during update\n        this.keys = {};\n\n    this.bearings = {\n      '-180': 'W',\n      '-168.75': 'WBN',\n      '-157.5': 'WNW',\n      '-146.25': 'NWBW',\n      '-135': 'NW',\n      '-123.75': 'NWBN',\n      '-112.5': 'NNW',\n      '-101.25': 'NBW',\n      '-90': 'N',\n      '-78.75': 'NBE',\n      '-67.5': 'NNE',\n      '-56.25': 'NEBN',\n      '-45': 'NE',\n      '-33.75': 'NEBE',\n      '-22.5': 'EBE',\n      '-11.25': 'EBN',\n      '0': 'E',\n      '11.25': 'EBS',\n      '22.5': 'ESE',\n      '33.75': 'SEBE',\n      '45': 'SE',\n      '56.25': 'SEBS',\n      '67.5': 'SSE',\n      '78.75': 'SBE',\n      '90': 'S',\n      '101.25': 'SBW',\n      '112.5': 'SSW',\n      '123.75': 'SWBS',\n      '135': 'SW',\n      '146.25': 'SWBW',\n      '157.5': 'WSW',\n      '168.75': 'WBS',\n      '180': 'W'\n    };\n  }\n\n  refreshGamepads() {\n    // Sometimes, gamepads are undefined. For some reason.\n    this.gamepads = this.systems.input.gamepad.gamepads.filter(function (el) {\n      return el != null;\n    });\n\n    for (const [index, thisGamepad] of this.gamepads.entries()) {\n      thisGamepad.index = index; // Overwrite the gamepad index, in case we had undefined gamepads earlier\n    }\n  }\n\n    boot() {\n        this.eventEmitter = this.systems.events;\n        this.eventEmitter.on('update', this.update, this);\n\n    // Gamepad\n        if (typeof this.systems.input.gamepad !== 'undefined') {\n            this.systems.input.gamepad.once('connected', function (thisGamepad) {\n        this.refreshGamepads();\n        this.setupGamepad(thisGamepad)\n      }, this);\n\n      // Check to see if the gamepad has already been setup by the browser\n      this.systems.input.gamepad.refreshPads();\n      if (this.systems.input.gamepad.total) {\n        this.refreshGamepads();\n        for (const thisGamepad of this.gamepads) {\n          this.systems.input.gamepad.emit('connected', thisGamepad);\n        }\n      }\n        }\n\n        // Keyboard\n        this.systems.input.keyboard.on('keydown', function (event){\n            let keyCode = Object.keys(Phaser.Input.Keyboard.KeyCodes).find(key => Phaser.Input.Keyboard.KeyCodes[key] === event.keyCode);\n            let playerIndex = this.getPlayerIndexFromKey(keyCode);\n            if (playerIndex > -1) {\n                this.getPlayer(playerIndex).interaction.device = 'keyboard';\n            }\n        }, this);\n        this.systems.input.keyboard.on('keyup', function (){\n            let keyCode = Object.keys(Phaser.Input.Keyboard.KeyCodes).find(key => Phaser.Input.Keyboard.KeyCodes[key] === event.keyCode);\n            let playerIndex = this.getPlayerIndexFromKey(keyCode);\n            if (playerIndex > -1) {\n                this.getPlayer(playerIndex).interaction.device = 'keyboard';\n            }\n    }, this);\n\n\n    // Pointer\n    this.systems.input.mouse.disableContextMenu();\n\n    this.systems.input.on('pointermove', function (pointer) {\n      this.pointerMove(pointer);\n    }, this);\n\n    this.systems.input.on('pointerdown', function (pointer) {\n      this.pointerDown(pointer);\n    }, this);\n\n    this.systems.input.on('pointerup', function (pointer) {\n      this.pointerUp(pointer);\n    }, this);\n    }\n\n    update() {\n        // Loop through players and manage buffered input\n        for (let thisPlayer of this.players) {\n            if (thisPlayer.interaction.buffer == '') {\n                thisPlayer.interaction.pressed = '';\n            }\n            if (thisPlayer.interaction.pressed != '') {\n                thisPlayer.interaction.buffer = '';\n      }\n\n      // If the pointer hasn't moved, and the scene has changed, this can end up as undefined\n      thisPlayer.pointer.BEARING          = typeof thisPlayer.pointer.BEARING != 'undefined' ? thisPlayer.pointer.BEARING : '';\n      thisPlayer.pointer.BEARING_DEGREES      = typeof thisPlayer.pointer.BEARING_DEGREES != 'undefined' ? thisPlayer.pointer.BEARING_DEGREES : 0;\n      thisPlayer.pointer.ANGLE          = typeof thisPlayer.pointer.ANGLE != 'undefined' ? thisPlayer.pointer.ANGLE : '';\n\n\n      thisPlayer.direction.BEARING        = this.mapDirectionsToBearing(thisPlayer.direction);\n      thisPlayer.direction.BEARING_LAST       = thisPlayer.direction.BEARING != '' ? thisPlayer.direction.BEARING : thisPlayer.direction.BEARING_LAST;\n      thisPlayer.direction.DEGREES        = thisPlayer.direction.BEARING != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction.BEARING)) : 0;\n      thisPlayer.direction.DEGREES_LAST       = thisPlayer.direction.BEARING_LAST != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction.BEARING_LAST)) : 0;\n      thisPlayer.direction_secondary.BEARING    = this.mapDirectionsToBearing(thisPlayer.direction_secondary);\n      thisPlayer.direction_secondary.BEARING_LAST = thisPlayer.direction_secondary.BEARING != '' ? thisPlayer.direction_secondary.BEARING : thisPlayer.direction_secondary.BEARING_LAST;\n      thisPlayer.direction_secondary.DEGREES    = thisPlayer.direction_secondary.BEARING != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction_secondary.BEARING)) : 0;\n      thisPlayer.direction_secondary.DEGREES_LAST = thisPlayer.direction_secondary.BEARING_LAST != '' ? parseFloat(this.mapBearingToDegrees(thisPlayer.direction_secondary.BEARING_LAST)) : 0;\n        }\n\n        this.checkKeyboardInput();\n    this.checkGamepadInput();\n    this.checkPointerInput();\n    }\n\n  /**\n   * Set up the gamepad and associate with a player object\n   */\n  setupGamepad(thisGamepad) {\n    thisGamepad.on('down', this.gamepadButtonDown, this);\n    thisGamepad.on('up', this.gamepadButtonUp, this);\n    this.eventEmitter.emit('mergedInput', {device:'gamepad', id:thisGamepad.id, player:thisGamepad.index, action:'Connected'});\n    if (typeof this.players[thisGamepad.index] === 'undefined') {\n      this.addPlayer();\n    }\n    this.players[thisGamepad.index].gamepad = thisGamepad;\n  }\n\n    /**\n     * Add a new player object to the players array\n   * @param {number} index Player index - if a player object at this index already exists, it will be returned instead of creating a new player object\n     */\n    addPlayer(index) {\n    if (typeof Number.isInteger(index) && typeof this.players[index] !== 'undefined') {\n      return this.players[index];\n    }\n    else {\n      this.players.push(this.setupControls());\n      this.players[this.players.length-1].index = this.players.length-1;\n      return this.players[this.players.length-1];\n    }\n    }\n\n    /**\n     * Get player object\n     * @param {number} index Player index\n     */\n    getPlayer(index) {\n        return typeof this.players[index] !== 'undefined' ? this.players[index] : ''\n    }\n\n    getPlayerIndexFromKey(key) {\n        for (let thisPlayer of this.players) {\n            // Loop through all the keys assigned to this player\n            for (var thisKey in thisPlayer.keys) {\n                for (var thisValue of thisPlayer.keys[thisKey]) {\n                    if (thisValue == key) {\n                        return thisPlayer.index;\n                    }\n                }\n            }\n        }\n        return -1;\n    }\n\n    /**\n     * Returns a struct to hold input control information\n     * Set up a struct for each player in the game\n     * Direction and Buttons contain the input from the devices\n     * The keys struct contains arrays of keyboard characters that will trigger the action\n     */\n    setupControls() {\n        let controls = {\n            'direction': {\n                'UP': 0,\n                'DOWN': 0,\n                'LEFT': 0,\n        'RIGHT': 0,\n        'BEARING': '',\n        'BEARING_LAST': '',\n        'DEGREES': 0,\n        'DEGREES_LAST': 0,\n        'TIMESTAMP': 0\n      },\n            'direction_secondary': {\n                'UP': 0,\n                'DOWN': 0,\n                'LEFT': 0,\n        'RIGHT': 0,\n        'BEARING': '',\n        'DEGREES': 0,\n        'BEARING_LAST': '',\n        'DEGREES_LAST': 0,\n        'TIMESTAMP': 0\n            },\n            'buttons': {},\n      'pointer': {\n        'M1': 0,\n        'M2': 0,\n        'M3': 0,\n        'M4': 0,\n        'M5': 0,\n        'BEARING': '',\n        'BEARING_DEGREES': 0,\n        'ANGLE': 0,\n        'TIMESTAMP': 0\n      },\n      'position': {},\n            'interaction': {},\n            'gamepad': {},\n            'keys': {\n                'UP': [],\n                'DOWN': [],\n                'LEFT': [],\n                'RIGHT': [],\n      }\n        }\n        for (let i=1; i<=16; i++) {\n            controls.buttons['B'+i] = 0;\n            controls.keys['B'+i] = [];\n        }\n\n        controls.interaction.buffer = '';\n        controls.interaction.pressed = '';\n        controls.interaction.last = '';\n        controls.interaction.device = '';\n\n        return controls;\n    }\n\n    // Keyboard functions\n\n    /**\n     * Define a key for a player/action combination\n     * @param {number} player The player on which we're defining a key\n     * @param {string} action The action to define\n     * @param {string} value The key to use\n     * @param {boolean} append When true, this key definition will be appended to the existing key(s) for this action\n     */\n    defineKey(player = 0, action, value, append = false) {\n        // Set up a new player if none defined\n        if (typeof this.players[player] === 'undefined') {\n            this.addPlayer();\n        }\n\n        if (['UP','DOWN','LEFT','RIGHT','ALT_UP','ALT_DOWN','ALT_LEFT','ALT_RIGHT','B0','B1','B2','B3','B4','B5','B6','B7','B8','B9','B10','B11','B12','B13','B14','B15','B16'].includes(action)) {\n            if (append && (typeof this.players[player].keys[action] !== 'undefined')) {\n                this.players[player].keys[action].push([value]);\n            }\n            else {\n                this.players[player].keys[action] = [];\n                this.players[player].keys[action].push([value]);\n            }\n\n            this.keys[[value]] = this.systems.input.keyboard.addKey(Phaser.Input.Keyboard.KeyCodes[value]);\n        }\n\n        return this;\n    }\n\n    /**\n     * Iterate through players and check for interaction with defined keys\n     */\n    checkKeyboardInput() {\n        // Loop through players and check for keypresses - use of 'entries()' gives us an index to use for the player\n        for (let [playerIndex, thisPlayer] of this.players.entries()) {\n            // Loop through all the keys assigned to this player\n            for (var thisKey in thisPlayer.keys) {\n                let action = 0;\n                for (var thisValue of thisPlayer.keys[thisKey]) {\n                    // Check if the key is down\n                    action = (this.keys[thisValue].isDown) ? 1 : action;\n\n                    // Emit events based on the key down and up values\n                    if(Phaser.Input.Keyboard.JustDown(this.keys[thisValue])) {\n                        this.eventEmitter.emit('mergedInput', {device:'keyboard', value:1, player:playerIndex, action:thisKey, state: 'DOWN'});\n                        // Update the last button state\n                        thisPlayer.interaction.pressed = thisKey;\n                        thisPlayer.interaction.buffer = thisKey;\n            thisPlayer.interaction.last = thisKey;\n\n                    }\n                    if(Phaser.Input.Keyboard.JustUp(this.keys[thisValue])) {\n            this.eventEmitter.emit('mergedInput', {device:'keyboard', value:1, player:playerIndex, action:thisKey, state: 'UP'});\n                    }\n                }\n\n                // Set the action in the player object\n                if (['UP','DOWN','LEFT','RIGHT'].includes(thisKey)) {\n          thisPlayer.direction[thisKey] = action;\n          thisPlayer.direction.TIMESTAMP = this.scene.sys.time.now;\n        }\n                else if (['ALT_UP','ALT_DOWN','ALT_LEFT','ALT_RIGHT'].includes(thisKey)) {\n          thisPlayer.direction_secondary[thisKey.replace('ALT_', '')] = action;\n          if (action == 1) {\n            thisPlayer.direction_secondary.TIMESTAMP = this.scene.sys.time.now;\n          }\n                }\n                else {\n          thisPlayer.buttons[thisKey] = action;\n          if (action == 1) {\n            thisPlayer.buttons.TIMESTAMP = this.scene.sys.time.now;\n          }\n                }\n\n                // Set the latest interaction flag\n                if (action == 1) {\n          thisPlayer.interaction.device = 'keyboard';\n                }\n            }\n        }\n    }\n\n\n\n    /**\n     * Iterate through players and check for interaction with defined pointer buttons\n     */\n    checkPointerInput() {\n    // Loop through players and check for button presses - use of 'entries()' gives us an index to use for the player\n        for (let [playerIndex, thisPlayer] of this.players.entries()) {\n            // Loop through all the keys assigned to this player\n            for (var thisKey in thisPlayer.keys) {\n        for (var thisValue of thisPlayer.keys[thisKey]) { // Each definition for this key action\n          if (['M1','M2','M3','M4','M5'].includes(thisValue[0])) {\n            // Check to see if button is pressed (stored in P1, can't have two mice...)\n            if (this.players[0].pointer[thisValue] == 1) {\n              thisPlayer.buttons[thisKey] = 1;\n            }\n          }\n        }\n            }\n        }\n    }\n\n\n    // Gamepad functions\n\n    /**\n     * When a gamepad button is pressed down, this function will emit a mergedInput event in the global registry.\n     * The event contains a reference to the player assigned to the gamepad, and passes a mapped action and value\n     * @param {number} index Button index\n     * @param {number} value Button value\n     * @param {Phaser.Input.Gamepad.Button} button Phaser Button object\n     */\n    gamepadButtonDown(index, value, button){\n    this.players[button.pad.index].interaction.device = 'gamepad';\n\n    this.eventEmitter.emit('mergedInput', {device:'gamepad', value:value, player:button.pad.index, action:'B' + index, state: 'DOWN'});\n\n        // DPad mapping\n        if (index === 12) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'UP', state: 'DOWN'});\n        }\n        if (index === 13) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'DOWN', state: 'DOWN'});\n        }\n        if (index === 14) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'LEFT', state: 'DOWN'});\n        }\n        if (index === 15) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'RIGHT', state: 'DOWN'});\n        }\n\n        // Last button pressed\n        if (![12,13,14,15].includes(index)) {\n      // Update the last button state\n            this.players[button.pad.index].interaction.pressed = 'B' + index;\n            this.players[button.pad.index].interaction.last = 'B' + index;\n      this.players[button.pad.index].interaction.buffer = 'B' + index;\n      this.players[button.pad.index].buttons.TIMESTAMP = this.scene.sys.time.now;\n    }\n    else {\n      this.players[button.pad.index].direction.TIMESTAMP = this.scene.sys.time.now;\n    }\n    }\n\n    /**\n     * When a gamepad button is released, this function will emit a mergedInput event in the global registry.\n     * The event contains a reference to the player assigned to the gamepad, and passes a mapped action and value\n     * @param {number} index Button index\n     * @param {number} value Button value\n     * @param {Phaser.Input.Gamepad.Button} button Phaser Button object\n     */\n    gamepadButtonUp(index, value, button){\n        this.players[button.pad.index].interaction.device = 'gamepad';\n        this.eventEmitter.emit('mergedInput', {device:'gamepad', value:value, player:button.pad.index, action:'B' + index, state: 'UP'});\n        // DPad mapping\n        if (index === 12) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'UP', state: 'UP'});\n        }\n        if (index === 13) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'DOWN', state: 'UP'});\n        }\n        if (index === 14) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'LEFT', state: 'UP'});\n        }\n        if (index === 15) {\n            this.eventEmitter.emit('mergedInput', {device:'gamepad', value:1, player:button.pad.index, action:'RIGHT', state: 'UP'});\n    }\n\n        if (![12,13,14,15].includes(index)) {\n      // Update the last button state\n      this.players[button.pad.index].buttons.TIMESTAMP = this.scene.sys.time.now;\n    }\n    else {\n      this.players[button.pad.index].direction.TIMESTAMP = this.scene.sys.time.now;\n    }\n    }\n\n    /**\n     * Iterate through gamepads and handle interactions\n     */\n    checkGamepadInput() {\n        // Check for gamepad input\n        for (var thisGamepad of this.gamepads) {\n            // Directions\n            if (thisGamepad.leftStick.y < -0.5) {\n        this.players[thisGamepad.index].direction.UP = Math.abs(thisGamepad.leftStick.y)\n        this.players[thisGamepad.index].direction.TIMESTAMP = this.scene.sys.time.now;\n            }\n            else if (thisGamepad.leftStick.y > 0.5) {\n        this.players[thisGamepad.index].direction.DOWN = thisGamepad.leftStick.y\n        this.players[thisGamepad.index].direction.TIMESTAMP = this.scene.sys.time.now;\n            }\n            else if (this.players[thisGamepad.index].interaction.device === 'gamepad') {\n                // DPad\n                this.players[thisGamepad.index].direction.UP = thisGamepad.up ? 1 : 0;\n                this.players[thisGamepad.index].direction.DOWN = thisGamepad.down ? 1 : 0;\n            }\n\n            if (thisGamepad.leftStick.x < -0.5) {\n        this.players[thisGamepad.index].direction.LEFT = Math.abs(thisGamepad.leftStick.x)\n        this.players[thisGamepad.index].direction.TIMESTAMP = this.scene.sys.time.now;\n            }\n            else if (thisGamepad.leftStick.x > 0.5) {\n        this.players[thisGamepad.index].direction.RIGHT = thisGamepad.leftStick.x\n        this.players[thisGamepad.index].direction.TIMESTAMP = this.scene.sys.time.now;\n            }\n            else if (this.players[thisGamepad.index].interaction.device === 'gamepad') {\n                // DPad\n                this.players[thisGamepad.index].direction.LEFT = thisGamepad.left ? 1 : 0;\n                this.players[thisGamepad.index].direction.RIGHT = thisGamepad.right ? 1 : 0;\n      }\n\n            // Secondary\n            if (thisGamepad.rightStick.y < -0.5) {\n        this.players[thisGamepad.index].direction_secondary.UP = Math.abs(thisGamepad.rightStick.y)\n        this.players[thisGamepad.index].direction_secondary.TIMESTAMP = this.scene.sys.time.now;\n            }\n            else if (thisGamepad.rightStick.y > 0.5) {\n        this.players[thisGamepad.index].direction_secondary.DOWN = thisGamepad.rightStick.y\n        this.players[thisGamepad.index].direction_secondary.TIMESTAMP = this.scene.sys.time.now;\n      }\n      else {\n        this.players[thisGamepad.index].direction_secondary.UP = 0;\n        this.players[thisGamepad.index].direction_secondary.DOWN = 0;\n      }\n\n            if (thisGamepad.rightStick.x < -0.5) {\n        this.players[thisGamepad.index].direction_secondary.LEFT = Math.abs(thisGamepad.rightStick.x)\n        this.players[thisGamepad.index].direction_secondary.TIMESTAMP = this.scene.sys.time.now;\n            }\n            else if (thisGamepad.rightStick.x > 0.5) {\n        this.players[thisGamepad.index].direction_secondary.RIGHT = thisGamepad.rightStick.x\n        this.players[thisGamepad.index].direction_secondary.TIMESTAMP = this.scene.sys.time.now;\n            }\n      else {\n        this.players[thisGamepad.index].direction_secondary.LEFT = 0;\n        this.players[thisGamepad.index].direction_secondary.RIGHT = 0;\n      }\n\n            if (this.players[thisGamepad.index].interaction.device === 'gamepad') {\n                // Buttons\n                for (var b = 0; b < thisGamepad.buttons.length; b++) {\n                    let button = thisGamepad.buttons[b];\n                    this.players[thisGamepad.index].buttons['B' + b] = button.value;\n                }\n            }\n        }\n    }\n\n\n  /**\n   * Function to run on pointer move.\n   * @param {*} pointer - The pointer object\n   */\n  pointerMove(pointer, threshold) {\n    var threshold = threshold || 0;\n    if (pointer.distance > threshold) {\n      let pointerDirection = this.getBearingFromAngle(pointer.angle, 8);\n      // this.players[0].direction_secondary = this.mapBearingToDirections(pointerDirection);\n\n      // If we've been given a player position, return bearings and angles\n      if (typeof this.players[0] !== 'undefined' && this.players[0].position.x !== 'undefined') {\n        let position      = this.players[0].position;\n        let angleToPointer    = Phaser.Math.Angle.Between(position.x, position.y, pointer.worldX, pointer.worldY);\n        let pointerDirection  = this.getBearingFromAngle(angleToPointer, 8);\n        let pointerAngle    = Number(this.mapBearingToDegrees(pointerDirection));\n\n        this.players[0].pointer.BEARING     = pointerDirection;\n        this.players[0].pointer.ANGLE       = angleToPointer;\n        this.players[0].pointer.BEARING_DEGREES = pointerAngle;\n        this.players[0].pointer.TIMESTAMP   = this.scene.sys.time.now;\n      }\n    }\n  }\n\n\n  /**\n   * Function to run on pointer down. Indicates that Mx has been pressed, which should be listened to by the player object\n   * @param {*} pointer - The pointer object\n   */\n  pointerDown(pointer) {\n    let action = '';\n    this.players[0].interaction.device = 'pointer';\n    if (pointer.leftButtonDown()) {\n      action = 'M1';\n    }\n    if (pointer.rightButtonDown()) {\n      action = 'M2';\n    }\n    if (pointer.middleButtonDown()) {\n      action = 'M3';\n    }\n    if (pointer.backButtonDown()) {\n      action = 'M4';\n    }\n    if (pointer.forwardButtonDown()) {\n      action = 'M5';\n    }\n\n        this.eventEmitter.emit('mergedInput', {device:'pointer', value:1, player:0, action:action, state: 'DOWN'});\n\n    this.players[0].pointer[action] = 1;\n\n    // Update the last button state\n    this.players[0].interaction.pressed = action;\n    this.players[0].interaction.last = action;\n    this.players[0].interaction.buffer = action;\n    this.players[0].pointer.TIMESTAMP = pointer.moveTime;\n  }\n\n\n  /**\n   * Function to run on pointer up. Indicates that Mx has been released, which should be listened to by the player object\n   * @param {*} pointer - The pointer object\n   */\n  pointerUp(pointer) {\n    let action = '';\n    if (pointer.leftButtonReleased()) {\n      action = 'M1';\n    }\n    if (pointer.rightButtonReleased()) {\n      action = 'M2';\n    }\n    if (pointer.middleButtonReleased()) {\n      action = 'M3';\n    }\n    if (pointer.backButtonReleased()) {\n      action = 'M4';\n    }\n    if (pointer.forwardButtonReleased()) {\n      action = 'M5';\n    }\n\n    this.eventEmitter.emit('mergedInput', {device:'pointer', value:1, player:0, action:action, state: 'UP'});\n\n    this.players[0].pointer[action]   = 0;\n    this.players[0].pointer.TIMESTAMP = this.scene.sys.time.now;\n  }\n\n\n  /**\n   * Get the bearing from a given angle\n   * @param {float} angle - Angle to use\n   * @param {number} numDirections - Number of possible directions (e.g. 4 for N/S/E/W)\n   */\n  getBearingFromAngle(angle, numDirections, threshold) {\n    var numDirections = numDirections || 8;\n\n    var snap_interval = Phaser.Math.PI2 / numDirections;\n\n    var angleSnap     = Phaser.Math.Snap.To(angle, snap_interval);\n    var angleSnapDeg  = Phaser.Math.RadToDeg(angleSnap);\n    var angleSnapDir  = this.bearings[angleSnapDeg];\n\n    return angleSnapDir;\n  }\n\n\n  /**\n   * Given a bearing, return a direction object containing boolean flags for the four directions\n   * @param {*} bearing\n   */\n  mapBearingToDirections(bearing) {\n    let thisDirection = {\n      'UP': 0,\n      'DOWN': 0,\n      'LEFT': 0,\n      'RIGHT': 0,\n      'BEARING': bearing.toUpperCase()\n    }\n\n    if (bearing.toUpperCase().includes('W')) {\n      thisDirection.LEFT = 1;\n    }\n    if (bearing.toUpperCase().includes('E')) {\n      thisDirection.RIGHT = 1;\n    }\n    if (bearing.toUpperCase().includes('S')) {\n      thisDirection.DOWN = 1;\n    }\n    if (bearing.toUpperCase().includes('N')) {\n      thisDirection.UP = 1;\n    }\n\n    return thisDirection;\n  }\n\n\n  /**\n   * Given a directions object, return the applicable bearing (8 way only)\n   * @param {*} directions\n   */\n  mapDirectionsToBearing(directions, threshold) {\n    var threshold = threshold || -.5\n        if (directions.UP && !(directions.LEFT || directions.RIGHT)) {\n            return 'N';\n        }\n        if (directions.RIGHT && directions.UP) {\n            return 'NE';\n        }\n        if (directions.RIGHT && !(directions.UP || directions.DOWN)) {\n            return 'E';\n        }\n        if (directions.RIGHT && directions.DOWN) {\n            return 'SE';\n        }\n        if (directions.DOWN && !(directions.LEFT || directions.RIGHT)) {\n            return 'S';\n        }\n        if (directions.LEFT && directions.DOWN) {\n            return 'SW';\n        }\n        if (directions.LEFT && !(directions.UP || directions.DOWN)) {\n            return 'W';\n        }\n        if (directions.LEFT && directions.UP) {\n            return 'NW';\n    }\n    return '';\n  }\n\n  /**\n   * Given a bearing, return the snapped angle in degrees\n   * @param {*} bearing\n   */\n  mapBearingToDegrees(bearing) {\n    if (bearing != '') {\n      return Object.keys(this.bearings).find(key => this.bearings[key] === bearing);\n    }\n    else {\n      return '';\n    }\n  }\n\n\n    destroy() {\n        this.shutdown();\n        this.scene = undefined;\n    }\n\n    /**\n     * Return debug object\n     */\n    debug() {\n    // Debug variables\n    var debug = {\n            'input' : {}\n        };\n        debug.input.gamepads = [];\n        for (var i = 0; i < this.gamepads.length; i++) {\n            let pad = this.gamepads[i];\n            let buttons = {};\n            let axes = {};\n\n            for (var b = 0; b < pad.buttons.length; b++) {\n                let button = pad.buttons[b];\n                buttons['B' + button.index] = button.value;\n            }\n\n            for (var a = 0; a < pad.axes.length; a++) {\n                let axis = pad.axes[a];\n                axes['A' + axis.index] = axis.getValue();\n            }\n\n            debug.input.gamepads.push({\n                'ID':       pad.id,\n                'Index':    pad.index,\n                'Buttons':  buttons,\n                'Axes':     axes\n            });\n        }\n\n        debug.players = [];\n        for (let thisPlayer of this.players) {\n            debug.players.push({\n                'interaction': thisPlayer.interaction,\n                'device': thisPlayer.device,\n        'buttons': thisPlayer.buttons,\n        'pointer': thisPlayer.pointer,\n        'direction': thisPlayer.direction,\n        'direction_secondary': thisPlayer.direction_secondary,\n        'keys': thisPlayer.keys\n            })\n        }\n\n    return debug;\n    }\n}\n"],"sourceRoot":""}